import os
import random
import shutil
from colorama import init, Fore, Style
from collections import defaultdict
import time
from datetime import datetime as dt
from rich.console import Console
from rich.table import Table
from rich import box
from datetime import datetime
from rich.text import Text

# ===========================
# 🔹 Status helpers
# ===========================
def get_status(last_login_str: str) -> str:
    try:
        last_login_str = last_login_str.replace("WIB", "").strip()
        last_login = datetime.strptime(last_login_str, "%Y-%m-%d %H:%M:%S")
        now = datetime.now()
        days_offline = (now - last_login).days
        if days_offline <= 4:
            return "Active"
        elif days_offline <= 9:
            return "Semi Active"
        else:
            return "Inactive"
    except Exception:
        return "Unknown"

def parse_last_login(account):
    for detail in account['details']:
        if detail.lower().startswith("last log in"):
            last_login_str = detail.split(":", 1)[1].strip()
            try:
                last_login_str = last_login_str.replace("WIB", "").strip()
                last_login = datetime.strptime(last_login_str, "%Y-%m-%d %H:%M:%S")
                days_offline = (datetime.now() - last_login).days
                return days_offline
            except Exception:
                return None
    return None

def parse_account_block(block: str):
    skin = 0
    status = "Unknown"
    for line in block.splitlines():
        if line.strip().startswith("Skin"):
            try:
                skin = int(line.split(":")[1].strip())
            except:
                skin = 0
        elif line.strip().startswith("Last Log in"):
            last_login_str = line.split(":", 1)[1].strip()
            status = get_status(last_login_str)
    return skin, status

# ===========================
# 🔹 Init
# ===========================
init(autoreset=True)
console = Console()
EXPIRATION_DATE = dt(2026, 7, 13)

def check_expiration():
    if dt.now() > EXPIRATION_DATE:
        console.print("[bold red]\n[!] This script has expired. Please contact @Feithan for updates.[/bold red]")
        time.sleep(3)
        exit()

def get_terminal_width():
    return shutil.get_terminal_size().columns if hasattr(shutil, 'get_terminal_size') else 80

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

# ===========================
# 🔹 Banner
# ===========================
def print_banner():
    check_expiration()
    banner = Table(
        box=box.SQUARE,
        show_header=False,
        expand=True,
        padding=(0, 1),
    )
    banner.add_row("[bold cyan]ML ACCOUNT SELECTOR (DISTRIBUTOR)[/bold cyan]")
    banner.add_row("[yellow]Created by: @Feithan[/yellow]")
    console.print(banner)
    console.print("\n")

def print_section(title, error=False):
    width = get_terminal_width()
    border = Fore.RED + '─' * (width - 2) if error else Fore.MAGENTA + '─' * (width - 2)
    print('\n' + Fore.MAGENTA + '▶ ' + title + '\n' + border)

def print_message(text, message_type="info"):
    prefix = {
        "success": Fore.GREEN + "✓ ",
        "warning": Fore.YELLOW + "⚠ ",
        "error": Fore.RED + "✗ ",
        "loading": Fore.YELLOW + "⏳ ",
        "info": ""
    }.get(message_type, "")
    print(prefix + text + Style.RESET_ALL)

# ===========================
# 🔹 Parsing & grouping
# ===========================
def extract_account_details(lines):
    accounts = []
    current_account = None
    for line in lines:
        if line.strip():
            if line.strip()[0].isdigit() and '=>' in line:
                if current_account:
                    accounts.append(current_account)
                current_account = {'full_entry': line.strip(), 'details': []}
            elif current_account:
                current_account['details'].append(line.strip())
    if current_account:
        accounts.append(current_account)
    return accounts

def parse_skin_count(account):
    for detail in account['details']:
        if 'skin' in detail.lower():
            skin_part = detail.split(':')[-1].strip()
            digits = ''.join(filter(str.isdigit, skin_part))
            return int(digits) if digits else 0
    return 0

def group_accounts_by_skins(accounts):
    groups = defaultdict(list)
    for account in accounts:
        skins = parse_skin_count(account)
        if skins <= 200:
            group = "181-200"
        elif skins <= 300:
            group = "201-300"
        elif skins <= 400:
            group = "301-400"
        elif skins <= 500:
            group = "401-500"
        elif skins <= 600:
            group = "501-600"
        elif skins <= 700:
            group = "601-700"
        elif skins <= 800:
            group = "701-800"
        else:
            group = "801 Above"
        groups[group].append(account)
    return groups

def select_random_accounts(groups, num_accounts):
    total_accounts = sum(len(accounts) for accounts in groups.values())
    if num_accounts > total_accounts:
        num_accounts = total_accounts

    group_quota = {}
    for group, accounts in groups.items():
        ratio = len(accounts) / total_accounts
        group_quota[group] = int(ratio * num_accounts)

    assigned = sum(group_quota.values())
    leftover = num_accounts - assigned

    remainders = sorted(
        ((group, (len(groups[group]) / total_accounts) * num_accounts - group_quota[group])
         for group in groups),
        key=lambda x: x[1],
        reverse=True
    )

    for group, _ in remainders:
        if leftover <= 0:
            break
        if group_quota[group] < len(groups[group]):
            group_quota[group] += 1
            leftover -= 1

    selected = []
    for group, quota in group_quota.items():
        if groups[group]:
            random.shuffle(groups[group])
            selected.extend(groups[group][:quota])
            groups[group] = groups[group][quota:]

    return selected

# ===========================
# 🔹 File handling
# ===========================
def detect_txt_files():
    txt_files = []
    for file in os.listdir('.'):
        if file.endswith('.txt') and os.path.isfile(file):
            txt_files.append(file)
    return txt_files

def select_txt_file(txt_files):
    print_message("Detected txt files:", "info")
    for i, file in enumerate(txt_files, 1):
        print(f"{Fore.YELLOW}{i}. {Fore.CYAN}{file}{Style.RESET_ALL}")
    while True:
        try:
            choice = int(input(Fore.GREEN + "\nEnter the number of the file to use: " + Style.RESET_ALL))
            if 1 <= choice <= len(txt_files):
                return txt_files[choice - 1]
            print_message(f"Please enter a number between 1 and {len(txt_files)}", "error")
        except ValueError:
            print_message("Invalid input! Please enter a number.", "error")

# ===========================
# 🔹 Auto Cleaner
# ===========================
def auto_clean(accounts):
    seen = set()
    cleaned = []
    duplicates = 0
    low_skin_removed = 0

    for acc in accounts:
        skins = parse_skin_count(acc)
        unique_key = acc['full_entry'] + "|" + str(skins)

        if unique_key in seen:
            duplicates += 1
            continue
        seen.add(unique_key)

        if skins <= 180:  # ✅ auto remove low skin (≤180)
            low_skin_removed += 1
            continue

        cleaned.append(acc)

    print_message(f"Removed {duplicates} duplicate accounts", "warning")
    print_message(f"Removed {low_skin_removed} low-skin accounts (≤180)", "warning")
    return cleaned

# ===========================
# 🔹 Distribution UI
# ===========================
def show_distribution(valid_accounts):
    skin_ranges = {
        "180↓": 0, "181–200": 0, "201–300": 0,
        "301–400": 0, "401–500": 0, "501–600": 0,
        "601–700": 0, "701–800": 0, "801↑": 0,
    }

    for acc in valid_accounts:
        skins = parse_skin_count(acc)
        if skins <= 180: skin_ranges["180↓"] += 1
        elif skins <= 200: skin_ranges["181–200"] += 1
        elif skins <= 300: skin_ranges["201–300"] += 1
        elif skins <= 400: skin_ranges["301–400"] += 1
        elif skins <= 500: skin_ranges["401–500"] += 1
        elif skins <= 600: skin_ranges["501–600"] += 1
        elif skins <= 700: skin_ranges["601–700"] += 1
        elif skins <= 800: skin_ranges["701–800"] += 1
        else: skin_ranges["801↑"] += 1

    total = len(valid_accounts)

    table = Table(
        title=Text("🎨 SKIN COUNT DISTRIBUTION (Cleaned)", justify="center"),
        box=box.SQUARE,
    )
    table.add_column("Skin Range", justify="center", style="cyan")
    table.add_column("Count", justify="center", style="magenta")
    table.add_column("%", justify="center", style="green")
    table.add_column("Distribution", justify="left")

    for rng, count in skin_ranges.items():
        percent = (count / total * 100) if total else 0
        bar = "█" * int(percent / 5)
        table.add_row(rng, str(count), f"{percent:.0f}%", bar)

    console.print(table)
    console.print(f"[bold]Total valid (after cleaning):[/bold] {total}")

    suggested = max(50, min(100, total // 6))
    console.print(f"[bold]Suggested select count:[/bold] ~{suggested}")

# ===========================
# 🔹 Main
# ===========================
def main():
    try:
        while True:
            clear_screen()
            print_banner()

            txt_files = detect_txt_files()
            if not txt_files:
                print_message("No .txt files found in the current directory!", "error")
                time.sleep(2)
                return

            file_path = select_txt_file(txt_files)
            print_message(f"Selected file: {Fore.YELLOW}{file_path}", "success")

            try:
                with open(file_path, 'r', encoding="utf-8") as f:
                    lines = f.readlines()
            except Exception as e:
                print_message(f"Error reading file: {str(e)}", "error")
                time.sleep(2)
                continue

            accounts = extract_account_details(lines)
            if not accounts:
                print_message("No valid accounts found in file!", "error")
                time.sleep(2)
                continue

            # ✅ Auto Clean
            accounts = auto_clean(accounts)
            if not accounts:
                print_message("No accounts left after cleaning!", "error")
                time.sleep(2)
                continue

            # Show distribution
            show_distribution(accounts)

            # Selection setup
            print_section("SELECTION SETUP")
            while True:
                try:
                    num_to_select = int(input(Fore.GREEN + f"🛒 Number of accounts to select (1-{len(accounts)}): " + Style.RESET_ALL))
                    if 1 <= num_to_select <= len(accounts):
                        break
                    print_message(f"Please enter a number between 1 and {len(accounts)}", "error")
                except ValueError:
                    print_message("Invalid input! Please enter a number.", "error")

            print_message("Selecting accounts with balanced distribution...", "loading")
            time.sleep(1.5)

            groups = group_accounts_by_skins(accounts)
            selected = select_random_accounts(groups, num_to_select)
            if not selected:
                print_message("Failed to select accounts!", "error")
                time.sleep(2)
                continue

            selected.sort(key=lambda x: parse_skin_count(x), reverse=True)

            if not os.path.exists("Feithan"):
                os.makedirs("Feithan")

            output_file = os.path.join("Feithan", "selected_all.txt")
            try:
                with open(output_file, 'w', encoding="utf-8") as f:
                    for account in selected:
                        f.write(account['full_entry'] + "\n")
                        for detail in account['details']:
                            f.write(detail + "\n")
                        f.write("\n")
            except Exception as e:
                print_message(f"Error saving selected accounts: {str(e)}", "error")
                time.sleep(2)
                continue

            # Update original file
            remaining_accounts = [acc for acc in accounts if acc not in selected]
            try:
                with open(file_path, 'w', encoding="utf-8") as f:
                    for account in remaining_accounts:
                        f.write(account['full_entry'] + "\n")
                        for detail in account['details']:
                            f.write(detail + "\n")
                        f.write("\n")
            except Exception as e:
                print_message(f"Warning: Could not update original file: {str(e)}", "warning")

            if input("\n" + Fore.GREEN + "🔄 Select more accounts? (y/n): " + Style.RESET_ALL).lower() != 'y':
                break

    except KeyboardInterrupt:
        clear_screen()
        console.print("[bold cyan]╔══════════════════════════════════════════════════════════╗[/bold cyan]")
        console.print("[bold yellow]║   THANK YOU FOR USING ML ACCOUNT SELECTOR!              ║[/bold yellow]")
        console.print("[bold yellow]║   Created by: @Feithan                                 ║[/bold yellow]")
        console.print("[bold yellow]║   TG Channel: @official_Feithan                        ║[/bold yellow]")
        console.print("[bold cyan]╚══════════════════════════════════════════════════════════╝[/bold cyan]")

if __name__ == "__main__":
    main()